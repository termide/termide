# Архитектура

Этот документ описывает техническую архитектуру TermIDE.

## Общий обзор

TermIDE — это терминальная IDE, построенная на Rust с использованием TUI-фреймворка `ratatui`. Она имеет инновационную **систему компоновки панелей-аккордеон**, которая адаптируется к ширине терминала и обеспечивает эффективный многопанельный рабочий процесс.

```
┌─────────────────────────────────────────────────────────┐
│ Строка меню  [CPU] [RAM] [Часы]                         │
├──────────┬──────────────────────────────────────────────┤
│          │  ┌[X][▼] Редактор: main.rs ────────────┐    │
│          │  │                                      │    │
│   Файл.  │  │  fn main() {                         │    │
│  менеджер│  │      // код здесь                    │    │
│  (Статич)│  │  }                                   │    │
│          │  │                                      │    │
│          │  └──────────────────────────────────────┘    │
│          │  ─[X][▶] Терминал: bash ──────────────────   │
│          │  ─[X][▶] Отладка ──────────────────────────  │
├──────────┴──────────────────────────────────────────────┤
│ Статус: file.rs:42  Стр 10, Кол 5       Диск: 83%      │
└─────────────────────────────────────────────────────────┘
```

## Основные архитектурные компоненты

### 1. Система компоновки

#### 1.1 LayoutManager

**Расположение:** `src/layout_manager.rs`

`LayoutManager` — это сердце системы компоновки-аккордеон. Он управляет:

**Компоненты:**
- `file_manager: Option<Box<dyn Panel>>` - Статический файловый менеджер слева (всегда виден)
- `panel_groups: Vec<PanelGroup>` - Горизонтальное расположение групп панелей
- `focus: FocusTarget` - Текущий фокус (FileManager или Group(индекс))

**Ключевые обязанности:**
- Добавление панелей с автоматическим стекированием на основе порога ширины
- Управление горизонтальной навигацией (Alt+Left/Right)
- Управление вертикальной навигацией внутри групп (Alt+Up/Down)
- Умное стекирование/разделение панелей (Alt+Backspace)
- Закрытие панелей и очистка пустых групп

**Управление фокусом:**
```rust
pub enum FocusTarget {
    FileManager,     // Фокус на статическом файловом менеджере
    Group(usize),    // Фокус на группе панелей по индексу
}
```

Фокус определяет, какая панель получает ввод с клавиатуры/мыши и подсвечивается в UI.

#### 1.2 PanelGroup

**Расположение:** `src/panels/panel_group.rs`

`PanelGroup` представляет вертикальный стек панелей с поведением аккордеона.

**Структура:**
```rust
pub struct PanelGroup {
    panels: Vec<Box<dyn Panel>>,  // Панели в этой группе
    expanded_index: usize,         // Какая панель развёрнута
    horizontal_weight: u16,        // Вес компоновки (по умолчанию 100)
}
```

**Поведение аккордеона:**
- Ровно одна панель развёрнута (показывает полное содержимое)
- Остальные панели свёрнуты только в заголовок
- Клик по кнопке [▼]/[▶] в заголовке разворачивает/сворачивает
- Alt+Up/Down переключает между панелями в группе

**Ключевые операции:**
- `add_panel()` - Добавить панель в группу
- `remove_panel()` - Удалить панель (сбрасывает expanded_index при необходимости)
- `set_expanded()` - Изменить, какая панель развёрнута
- `next_panel()` / `prev_panel()` - Циклический переход по панелям

#### 1.3 Автоматическое стекирование

При добавлении новой панели через `LayoutManager::add_panel()`:

```rust
let new_width_if_split = available_width / (num_groups + 1);

if new_width_if_split < config.min_panel_width {
    // Стекировать вертикально в текущую группу (аккордеон)
    active_group.add_panel(panel);
} else {
    // Создать новую горизонтальную группу
    let new_group = PanelGroup::new(panel);
    panel_groups.push(new_group);
}
```

**Порог по умолчанию:** `min_panel_width = 80` символов

Это гарантирует, что панели всегда имеют достаточно места для использования.

### 2. Система панелей

#### 2.1 Трейт Panel

**Расположение:** `src/panels/mod.rs`

Все панели реализуют трейт `Panel`, который определяет интерфейс для интерактивных терминальных панелей:

```rust
pub trait Panel {
    /// Отрисовать содержимое панели
    fn render(
        &mut self,
        area: Rect,                // Доступная область рендеринга
        buf: &mut Buffer,          // Буфер ratatui
        is_focused: bool,          // Имеет ли эта панель фокус?
        panel_index: usize,        // Индекс панели для идентификации
        state: &AppState,          // Общее состояние приложения
    );

    /// Обработать ввод с клавиатуры
    fn handle_key(&mut self, key: KeyEvent) -> Result<()>;

    /// Обработать ввод мыши
    fn handle_mouse(&mut self, mouse: MouseEvent, panel_area: Rect) -> Result<()>;

    /// Получить заголовок панели (показывается в шапке)
    fn title(&self) -> String;

    /// Проверить, является ли это панелью приветствия (автоматически закрывается при открытии других)
    fn is_welcome_panel(&self) -> bool { false }

    /// Получить файл для открытия (для панелей, запрашивающих открытие файла)
    fn take_file_to_open(&mut self) -> Option<PathBuf> { None }

    /// Получить рабочую директорию для новых панелей
    fn get_working_directory(&self) -> Option<PathBuf> { None }

    /// Получить запрос модального окна (для панелей, открывающих модальные окна)
    fn take_modal_request(&mut self) -> Option<(PendingAction, ActiveModal)> { None }
}
```

#### 2.2 Реализации панелей

**FileManager** (`src/panels/file_manager/mod.rs`)
- Просмотр файлов и директорий
- Файловые операции (создание, удаление, копирование, перемещение)
- Интеграция с Git-статусом
- Поддержка буфера обмена
- Пакетные операции
- Выделение перетаскиванием

**Editor** (`src/panels/editor.rs`)
- Редактирование текста с отменой/повтором
- Подсветка синтаксиса через tree-sitter (15+ языков)
- Поиск и замена с интерактивными модальными окнами
- Номера строк, позиция курсора
- Сохранение файлов
- Настраиваемый размер табуляции

**TerminalPty** (`src/panels/terminal_pty.rs`)
- Полная поддержка PTY (псевдо-терминала)
- Интеграция с оболочкой
- Буфер прокрутки
- Поддержка ANSI-цветов
- Обработка изменения размера

**Debug** (`src/panels/debug.rs`)
- Инспекция состояния приложения
- Просмотр логов
- Информация о панелях
- Мониторинг системных ресурсов

**Welcome** (`src/panels/welcome.rs`)
- Показывается, когда нет открытых панелей
- Отображает текст помощи
- Автоматически закрывается при открытии других панелей

### 3. Обработка событий

#### 3.1 Цикл событий

**Расположение:** `src/app/mod.rs`

Структура основного цикла событий:

```rust
while !state.should_quit {
    match event_handler.next()? {
        Event::Key(key) => self.handle_key_event(key)?,
        Event::Mouse(mouse) => self.handle_mouse_event(mouse)?,
        Event::Resize(w, h) => state.update_terminal_size(w, h),
        Event::Tick => {
            // Периодические обновления
            self.update_panels_tick()?;
            self.system_monitor.update(&mut self.state);
        }
    }
    self.render(terminal)?;
}
```

**Типы событий:**
- **Key** - Ввод с клавиатуры (горячие клавиши, ввод текста)
- **Mouse** - Клики мыши, перетаскивание, прокрутка
- **Resize** - Изменение размера терминала
- **Tick** - Периодический таймер (мониторинг ресурсов, обновление панелей)

#### 3.2 Обработчик клавиш

**Расположение:** `src/app/key_handler.rs`

Обрабатывает ввод с клавиатуры с приоритетом:

1. **Модальное окно захватывает ввод первым** (если открыто)
2. **Глобальные горячие клавиши** (Alt+M, Alt+H, Alt+Q и т.д.)
3. **Управление панелями** (Alt+Left/Right, Alt+Up/Down, Alt+X и т.д.)
4. **Активная панель** (через `panel.handle_key()`)

**Поддержка кириллицы:**
Трансляция раскладки клавиатуры через `crate::keyboard::translate_hotkey()` позволяет горячим клавишам работать с русской раскладкой.

#### 3.3 Обработчик мыши

**Расположение:** `src/app/mouse_handler.rs`

Обрабатывает ввод мыши:

**Заголовок панели:**
- Клик по кнопке `[X]` → Закрыть панель
- Клик по кнопке `[▼]` → Свернуть панель (развернуть следующую)
- Клик по кнопке `[▶]` → Развернуть панель

**Содержимое панели:**
- Клики перенаправляются в `panel.handle_mouse()`
- Каждая панель обрабатывает свои собственные взаимодействия с мышью

**Строка меню:**
- Клик по пунктам меню для активации

#### 3.4 Обработчик модальных окон

**Расположение:** `src/app/modal_handler.rs` и `src/app/modal/`

Обрабатывает интерактивные модальные диалоги:

**Типы модальных окон:**
- **Input** - Ввод текста (имя файла, имя директории и т.д.)
- **Confirm** - Подтверждение Да/Нет
- **Select** - Выбор из вариантов
- **Batch** - Операции с несколькими элементами (копирование, перемещение, удаление)

**Захват ввода:**
Когда модальное окно открыто, ввод с клавиатуры сначала идёт в модальное окно. Escape закрывает модальное окно.

### 4. Конвейер рендеринга

#### 4.1 Основной рендеринг

**Расположение:** `src/ui/layout.rs`

Поток рендеринга:

```rust
fn render_layout_with_accordion(frame, layout_manager, state) {
    // 1. Вычислить горизонтальную компоновку (FM + группы)
    let horizontal_chunks = calculate_horizontal_layout();

    // 2. Отрисовать FileManager (если присутствует)
    if has_fm {
        render_file_manager(fm_area, ...);
    }

    // 3. Отрисовать группы панелей
    for group in groups {
        let vertical_chunks = calculate_vertical_layout(group);

        // 4. Отрисовать каждую панель (развёрнутую или свёрнутую)
        for panel in group {
            if is_expanded {
                render_expanded_panel(panel, area, ...);
            } else {
                render_collapsed_panel(panel, area, ...);
            }
        }
    }

    // 5. Отрисовать модальное окно (если открыто)
    if let Some(modal) = state.active_modal {
        render_modal(modal, ...);
    }
}
```

#### 4.2 Рендеринг панелей

**Расположение:** `src/ui/panel_rendering.rs`

**Развёрнутая панель:**
- Граница с кнопками `[X][▼]` и заголовком
- Полная область содержимого
- Прокручиваемо, если содержимое превышает область

**Свёрнутая панель:**
- Только заголовок: `─[X][▶] Заголовок ─────`
- Занимает минимум вертикального пространства (1 строка)
- Клик разворачивает

**Рендеринг границ:**
Границы и кнопки рисуются с помощью `panel_rendering.rs`, затем метод `render()` панели рисует содержимое во внутренней области.

### 5. Управление состоянием

#### 5.1 AppState

**Расположение:** `src/state.rs`

Центральный контейнер состояния:

```rust
pub struct AppState {
    pub theme: Theme,                    // Текущая тема
    pub terminal: TerminalInfo,          // Ширина, высота
    pub config: Config,                  // Конфигурация пользователя
    pub should_quit: bool,               // Флаг выхода
    pub batch_operation: Option<BatchOp>, // Ожидающие пакетные операции
    pub active_modal: Option<ActiveModal>, // Текущее модальное окно
    pub error_message: Option<String>,   // Ошибка для отображения
    pub fs_watcher: Option<Watcher>,     // Наблюдатель файловой системы
    // ... другие поля
}
```

**Потокобезопасность:**
Большая часть состояния однопоточная (TUI работает в главном потоке). Наблюдатель файловой системы использует каналы для межпоточной коммуникации.

#### 5.2 Конфигурация

**Расположение:** `src/config.rs`

Конфигурация пользователя загружается из TOML:

```rust
pub struct Config {
    pub theme: String,                    // Имя темы
    pub tab_size: usize,                  // Размер табуляции редактора
    pub language: String,                 // Язык UI (auto/en/ru)
    pub min_panel_width: u16,             // Порог стекирования
    pub resource_monitor_interval: u64,   // Интервал обновления (мс)
    pub log_file_path: Option<String>,    // Пользовательский путь к логам
}
```

**Расположения по умолчанию:**
- Linux: `~/.config/termide/config.toml`
- macOS: `~/Library/Application Support/termide/config.toml`
- Windows: `%APPDATA%\\termide\\config.toml`

### 6. Система тем

**Расположение:** `src/theme.rs`

**Встроенные темы:** 12 тем (Dracula, Nord, Monokai и др.)

**Пользовательские темы:** Загрузка из `~/.config/termide/themes/*.toml`

**Структура темы:**
```rust
pub struct Theme {
    pub fg: Color,                // Передний план
    pub bg: Color,                // Фон
    pub accented_fg: Color,       // Элементы с фокусом
    pub disabled: Color,          // Отключённые/без фокуса
    pub selected_bg: Color,       // Фон выделения
    // ... цвета подсветки синтаксиса
}
```

**Приоритет загрузки:**
1. Пользовательские темы (в директории конфигурации)
2. Встроенные темы
3. Откат на тему по умолчанию

### 7. Интернационализация

**Расположение:** `src/i18n/`

Языковая поддержка через строковые константы времени компиляции:

```rust
pub struct I18n {
    pub menu_files: &'static str,
    pub menu_terminal: &'static str,
    // ... все строки UI
}
```

**Языки:**
- Английский (`en.rs`)
- Русский (`ru.rs`)

**Определение:**
1. Настройка `config.language`
2. Переменная окружения `TERMIDE_LANG`
3. Системные переменные `LANG` / `LC_ALL`
4. По умолчанию английский

### 8. Ключевые зависимости

**Ratatui** - Фреймворк терминального UI
- Рендеринг на основе виджетов
- Буферная система для эффективных обновлений
- Система компоновки (Rect, Constraints)

**Crossterm** - Кроссплатформенное управление терминалом
- Обработка событий (клавиатура, мышь, изменение размера)
- Управление терминалом (курсор, цвета, очистка)
- Управление raw режимом

**Tree-sitter** - Подсветка синтаксиса
- Генераторы парсеров для 15+ языков
- Инкрементальный парсинг для производительности
- Система запросов для подсветки синтаксиса

**Ropey** - Текстовый буфер
- Эффективное построчное хранение текста
- Работа с UTF-8
- Gap buffer внутри

**Portable-pty** - Реализация PTY
- Кроссплатформенный псевдо-терминал
- Интеграция с оболочкой
- Поддержка изменения размера

**Sysinfo** - Системный мониторинг
- Использование CPU
- Использование памяти
- Дисковое пространство

## Архитектурные решения

### Почему компоновка-аккордеон?

**Проблема:** Пространство терминала ограничено, многопанельные IDE часто кажутся тесными.

**Решение:** Компоновка-аккордеон максимизирует используемое пространство:
- Одна развёрнутая панель на группу получает всё вертикальное пространство
- Другие панели сворачиваются в заголовок (1 строка)
- Быстрый доступ через Alt+Up/Down или клик мыши
- Автоматическое стекирование при слишком узком терминале

### Почему динамические панели?

**Преимущество:** Пользователи могут открывать столько панелей, сколько нужно:
- Несколько редакторов для разных файлов
- Несколько терминалов для разных задач
- Несколько файловых менеджеров для разных директорий

**Вызов:** Эффективное управление множеством панелей
- Аккордеон предотвращает беспорядок
- Горячие клавиши обеспечивают быструю навигацию
- Экран приветствия автоматически закрывается

### Почему панели на основе трейтов?

**Гибкость:** Новые типы панелей можно добавлять без изменения основного кода
- Реализовать трейт `Panel`
- Добавить в логику создания панелей
- Работает с существующей системой компоновки

**Полиморфизм:** `Box<dyn Panel>` позволяет гетерогенные коллекции
- Единственный `Vec<Box<dyn Panel>>` содержит все типы панелей
- Единообразный рендеринг и обработка событий
- Накладные расходы динамической диспетчеризации незначительны для TUI

## Характеристики производительности

**Рендеринг:** O(n), где n = количество видимых панелей
- Только развёрнутые панели рендерят полное содержимое
- Свёрнутые панели рендерят одну строку

**Обработка событий:** O(1) для большинства операций
- Прямой доступ по индексу к панели с фокусом
- Поиск в хеш-таблице для привязок клавиш

**Память:** Линейно от количества панелей
- Каждая панель владеет своим состоянием
- Общий AppState небольшой
- Нет избыточного клонирования (используются ссылки)

**Файловые операции:** Асинхронно, где возможно
- Наблюдатель файловой системы использует отдельный поток
- Дебаунсинг предотвращает избыточные обновления

## Будущие архитектурные соображения

**Потенциальные улучшения:**

1. **Асинхронные панели**
   - Долго выполняющиеся операции (поиск, компиляция) не блокируют UI
   - Фоновые задачи с индикаторами прогресса

2. **Система плагинов**
   - Динамическая загрузка панелей
   - Пользовательские типы панелей
   - Интеграция со скриптами (Lua, Python)

3. **Управление сессиями**
   - Сохранение/восстановление компоновки панелей
   - Проектные рабочие пространства
   - Недавние файлы/директории

4. **Разделённый FileManager**
   - Позволить FileManager быть частью групп
   - Несколько FileManager'ов
   - Требует рефакторинга системы фокуса

5. **Сетевые панели**
   - SSH терминальные панели
   - Удалённые браузеры файлов
   - Совместное редактирование

## Отладка архитектуры

**Система логирования:**
- Все логи записываются в `termide.log` в директории конфигурации
- Уровни: INFO, ERROR, DEBUG
- Метки времени и префиксы компонентов
- Ротация логов для предотвращения неограниченного роста

**Панель отладки:**
- Живой просмотр состояния приложения
- Недавние записи логов
- Инспекция панелей
- Метрики производительности

**Обработка паник:**
- Восстановление терминала при панике
- Запись информации о панике в лог
- Показ сообщения об ошибке пользователю

## Соображения безопасности

**Инъекция в терминал:**
- ANSI escape-последовательности фильтруются в терминальной панели
- Пользовательский ввод санитизируется перед выполнением в оболочке

**Файловые операции:**
- Атаки через симлинки предотвращаются
- Проверки path traversal
- Проверка прав доступа перед операциями

**Лимиты ресурсов:**
- Лимит размера файла (100 МБ) для редактора
- Лимит буфера прокрутки для терминала
- Ротация логов для предотвращения исчерпания диска

## Заключение

Архитектура TermIDE приоритизирует:
- **Гибкость** - Динамическая система панелей адаптируется к потребностям пользователя
- **Эффективность** - Компоновка-аккордеон максимизирует используемое пространство
- **Расширяемость** - Дизайн на основе трейтов позволяет лёгкие дополнения
- **Надёжность** - Оборонительное программирование предотвращает сбои
- **Производительность** - Эффективный рендеринг и обработка событий

Система компоновки-аккордеон — ключевая инновация, которая отличает TermIDE от традиционных многопанельных терминальных приложений.
